# nicxlive: D言語からC++への変換方針

`nijilive` を C++ と CMake 3.31 でビルドする `nicxlive` プロジェクトを立ち上げるにあたり、D 言語コードを C++ に置き換える際の方針をまとめる。まずは GC 依存部のメモリ管理、テンプレートの変換、Boost の利用方針を優先して整理する。

## 全体的な進め方
- C++20 を前提（CMake 3.31 で `target_compile_features(... cxx_std_20)` を指定）し、標準ライブラリで置き換えられる部分を洗い出す。
- D のパッケージ階層を C++ の名前空間とディレクトリに 1 対 1 で対応させ、ビルド対象をモジュール単位で小さく分割する。
- 型・API の互換性を優先し、挙動差分がある箇所はコメントとテスト（将来）で明文化する。

## GC 依存部のメモリ管理
- **所有権の明確化**: D の GC 管理オブジェクトは、用途別に `std::unique_ptr`（単一所有）と `std::shared_ptr`/`std::weak_ptr`（共有）に分類する。生ポインタは「非所有」を原則とし、所有側からの `span`/参照でアクセスする。
- **階層構造（Node 親子）**: 親→子は `std::shared_ptr` で所有し、逆参照や兄弟・その他の参照は `std::weak_ptr` を基本とする。これによりツリー構造で GC 依存の循環を避け、子のライフタイムは親の共有所有に従う。
- **短命データの確保**: 一時配列やバッファは `std::pmr::monotonic_buffer_resource`＋`std::pmr` コンテナで置き換え、従来の GC による一括解放を「リソース破棄」で代替する。スレッドごとにリソースを持つ形で GC のスレッド局所性を模倣する。
- **グラフ構造の循環**: 既存の循環参照は `std::shared_ptr`＋`std::weak_ptr` でループを断つか、後述の `boost::intrusive_ptr` を用いた参照カウントで明示的に管理する。
- **破棄とクリーンアップ**: GC が担っていた解放・ファイナライズは RAII に置き換え、外部リソース保持クラスには必ずデストラクタと所有ポインタを用意する。例外安全を保つため、手続き的な `delete` は避ける。
- **スライス/Range**: D のスライスは `std::span` で表現し、スパンの背後にある所有コンテナ（`std::vector` 等）が生存していることをテストで保証する。

## テンプレートの変換
- **関数・型テンプレート**: D のテンプレート引数は C++ のテンプレート型引数／非型引数で表現し、`auto` テンプレートは C++20 の abbreviated function template で置き換える。
- **制約と分岐**: `if` 条件付きテンプレートや `static if` は `requires` 句／`if constexpr` に変換する。D の `is(...)` を使った判定は型特性（`std::is_same_v` など）とコンセプトで置き換える。
- **CTFE/`enum` 定数**: D のコンパイル時計算は `constexpr` 関数と `consteval` でカバーする。生成結果が型に影響する場合は、テンプレートパラメータとして値を渡す構造にする。
- **Mixin 的生成**: D の mixin に依存する箇所は、メタ関数と `if constexpr` の分岐に展開し直す。自動生成が必要な場合のみ、CMake 生成ステップ（`configure_file` やスクリプト）で補う。

## 行列・ベクトル計算
- **Boost.QVM を利用**: `Mat4`/`Vec2`/`Vec3`/`Vec4` は Boost.QVM の `mat`/`vec` を内部に保持するラッパで実装し、行列積・平行移動・回転・スケール・逆行列などは QVM の API に委譲する。自前行列演算の再実装は避け、QVM を統一的に利用する。
- **Transform**: TRS 合成や `calcOffset`、`toMat4`、逆行列生成は QVM を経由して実装する。回転は Euler → クォータニオン変換を QVM で行う。

## Boost 利用方針
- **原則**: まず標準ライブラリで代替し、必要最小限のみ Boost を採用する。採用箇所はラッパーヘッダに隠蔽し、将来の除去を容易にする。
- **利用候補**:
  - GC 風の参照管理や循環グラフには `boost::intrusive_ptr`（カスタムカウンタを埋め込める）を検討。性能と所有コストを確認し、`std::shared_ptr` との差分をコメントに残す。
  - 小さな固定長配列／短い動的配列は `boost::container::small_vector` を使用し、D の動的配列の軽量性を補う。
  - D の `std.variant` 相当が必要なら `boost::variant2`、UUID 生成が必要なら `boost::uuid` を使用。いずれも使用箇所を限定し、API 境界で `std::variant`/独自型にラップする。
- **ビルド**: CMake では `find_package(Boost REQUIRED COMPONENTS ...)` を用い、Boost 依存をターゲット単位でリンクする。ヘッダ専用の利用でもターゲットを明示し、依存範囲を可視化する。

## 次の準備
- D コード中で GC を前提にしている型／関数を列挙し、所有権モデル（単一／共有／短命）にタグ付けする。
- テンプレートと mixin の使用箇所を洗い出し、`requires`/`if constexpr` で表現可能か、生成ステップが必要かを分類する。
- Boost を使う候補を抽出し、標準ライブラリでの代替可否と性能要求を併記する。
