<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>nicxlive wasm webgl test</title>
  <style>
    html, body { margin: 0; padding: 0; background: #111; color: #ddd; font-family: monospace; }
    #ui { padding: 8px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    #workspace { display: flex; width: 100vw; height: calc(100vh - 64px); min-height: 480px; }
    #paramPanel {
      box-sizing: border-box;
      width: 360px;
      min-width: 360px;
      max-width: 360px;
      padding: 8px;
      border-top: 1px solid #333;
      border-right: 1px solid #333;
      overflow: auto;
      background: #101010;
    }
    #viewer { flex: 1; min-width: 0; display: flex; flex-direction: column; }
    .paramRow {
      display: grid;
      grid-template-columns: minmax(160px, 220px) 1fr 130px;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .paramRow code { color: #9ad; }
    .paramVal { color: #9f9; }
    .paramRow2D {
      display: grid;
      grid-template-columns: minmax(160px, 220px) 1fr 130px;
      align-items: start;
      gap: 8px;
      margin-bottom: 8px;
    }
    .paramCtrl {
      width: 120px;
      justify-self: start;
    }
    .xyPad {
      width: 120px;
      height: 120px;
      border: 1px solid #444;
      background:
        linear-gradient(#0000 49%, #333 50%, #0000 51%),
        linear-gradient(90deg, #0000 49%, #333 50%, #0000 51%),
        #151515;
      position: relative;
      touch-action: none;
      cursor: crosshair;
      user-select: none;
    }
    .xyDot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #9f9;
      border: 1px solid #071;
      position: absolute;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    .paramSlider {
      width: 120px;
      accent-color: #6fd18b;
    }
    #cv { flex: 1; width: 100%; min-height: 240px; display: block; }
    #log { display: none; }
    button { cursor: pointer; }
    select { min-width: 320px; background: #181818; color: #ddd; border: 1px solid #444; padding: 4px 6px; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Model</label>
    <select id="modelSelect"></select>
    <button id="refreshModels">refresh</button>
    <button id="start">start</button>
    <button id="stop" disabled>stop</button>
    <label>scale</label>
    <input id="scale" type="range" min="0.05" max="2.0" step="0.01" value="0.15" />
    <span id="scaleVal">0.15</span>
  </div>
  <div id="workspace">
    <div id="paramPanel"></div>
    <div id="viewer">
      <canvas id="cv"></canvas>
      <pre id="log"></pre>
    </div>
  </div>

  <script type="module">
    import {
      initWebGLBackend,
      renderCommands,
      NjgRenderCommandKind,
      MaskDrawableKind,
      configureNicxModule,
      loadNicxScriptOnce,
      waitNicxRuntimeReady,
      createNicxWasmCodec,
      createNicxWasmBindings,
    } from "../webgl_backend/webgl_backend.js";
    const WASM_TEST_VERSION = "wasm-index-2026-02-28-20";
    const WASM_TEST_LOG_ENABLED = false;

    const logEl = document.getElementById("log");
    const canvas = document.getElementById("cv");
    const startBtn = document.getElementById("start");
    const stopBtn = document.getElementById("stop");
    const scaleInput = document.getElementById("scale");
    const scaleVal = document.getElementById("scaleVal");
    const modelSelect = document.getElementById("modelSelect");
    const refreshModelsBtn = document.getElementById("refreshModels");
    const paramPanel = document.getElementById("paramPanel");
    let Module = null;
    let runtimeControl = null;
    let isLaunching = false;
    let wasmPrepared = false;

    async function prepareWasmRuntime() {
      if (wasmPrepared) return;
      configureNicxModule({ buildDir: "../build-wasm-check" });
      await loadNicxScriptOnce("../build-wasm-check/nicxlive.js");
      Module = window.Module;
      wasmPrepared = true;
    }
    function log(...args) {
      if (!WASM_TEST_LOG_ENABLED) return;
      const s = args.map((x) => (typeof x === "string" ? x : JSON.stringify(x))).join(" ");
      logEl.textContent += s + "\n";
      logEl.scrollTop = logEl.scrollHeight;
      console.log("[wasm-test]", ...args);
    }

    function hexPreview(bytes, maxLen = 16) {
      const n = Math.min(maxLen, bytes.length);
      let out = "";
      for (let i = 0; i < n; i += 1) {
        out += bytes[i].toString(16).padStart(2, "0");
      }
      return out;
    }

    async function fetchModelList() {
      const res = await fetch(`/models/__list?t=${Date.now()}`, {
        cache: "no-store",
        headers: { "Cache-Control": "no-cache" },
      });
      if (!res.ok) {
        throw new Error(`failed to list models: ${res.status}`);
      }
      const body = await res.json();
      const arr = Array.isArray(body?.models) ? body.models : [];
      return arr.filter((m) => typeof m === "string");
    }

    function fillModelSelect(models) {
      modelSelect.innerHTML = "";
      for (const m of models) {
        const opt = document.createElement("option");
        opt.value = m;
        opt.textContent = m;
        modelSelect.appendChild(opt);
      }
      if (!models.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(no .inx/.inp found)";
        modelSelect.appendChild(opt);
      }
      const defaultPath = "/models/model.inx";
      const hasDefault = models.includes(defaultPath);
      modelSelect.value = hasDefault ? defaultPath : (models[0] || "");
    }

    if (WASM_TEST_LOG_ENABLED) {
      console.log("[wasm-test] version:", WASM_TEST_VERSION);
      log("version:", WASM_TEST_VERSION);
    }

    function readU32(p) { return Module.HEAPU32[p >>> 2] >>> 0; }

    let wasmCodec = null;
    function getWasmCodec() {
      if (!wasmCodec) wasmCodec = createNicxWasmCodec(Module, { log });
      return wasmCodec;
    }

    function getWasmBindings() {
      return createNicxWasmBindings(getWasmCodec());
    }

    function createParameterControls(params, onChange) {
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const num = (v, fallback) => (Number.isFinite(v) ? v : fallback);
      paramPanel.innerHTML = "";
      if (!Array.isArray(params) || params.length === 0) {
        paramPanel.textContent = "parameters: none";
        return;
      }
      for (const p of params) {
        const minX = num(p?.min?.[0], -1);
        const minY = num(p?.min?.[1], -1);
        const maxX = num(p?.max?.[0], 1);
        const maxY = num(p?.max?.[1], 1);
        const defX = clamp(num(p?.defaults?.[0], 0), minX, maxX);
        const defY = clamp(num(p?.defaults?.[1], 0), minY, maxY);
        const isVec2 = !!p?.isVec2 && (maxY !== minY);

        if (isVec2) {
          const row = document.createElement("div");
          row.className = "paramRow2D";

          const nameEl = document.createElement("code");
          nameEl.textContent = `${p.name || "param"} (${p.uuid >>> 0})`;

          const pad = document.createElement("div");
          pad.className = "xyPad";
          const ctrl = document.createElement("div");
          ctrl.className = "paramCtrl";
          const dot = document.createElement("div");
          dot.className = "xyDot";
          pad.appendChild(dot);
          ctrl.appendChild(pad);

          const valueEl = document.createElement("span");
          valueEl.className = "paramVal";

          let curX = defX;
          let curY = defY;

          const updateDotAndLabel = () => {
            const tx = (curX - minX) / Math.max(1e-6, (maxX - minX));
            const ty = (curY - minY) / Math.max(1e-6, (maxY - minY));
            dot.style.left = `${(tx * 100).toFixed(3)}%`;
            dot.style.top = `${((1 - ty) * 100).toFixed(3)}%`;
            valueEl.textContent = `X:${curX.toFixed(3)} Y:${curY.toFixed(3)}`;
          };

          const updateFromClient = (clientX, clientY, emit) => {
            const rect = pad.getBoundingClientRect();
            const lx = clamp(clientX - rect.left, 0, rect.width);
            const ly = clamp(clientY - rect.top, 0, rect.height);
            const tx = rect.width > 0 ? (lx / rect.width) : 0;
            const ty = rect.height > 0 ? (ly / rect.height) : 0;
            curX = clamp(minX + tx * (maxX - minX), minX, maxX);
            curY = clamp(minY + (1 - ty) * (maxY - minY), minY, maxY);
            updateDotAndLabel();
            if (emit) onChange(p, curX, curY);
          };

          pad.addEventListener("pointerdown", (ev) => {
            if (pad.setPointerCapture) pad.setPointerCapture(ev.pointerId);
            updateFromClient(ev.clientX, ev.clientY, true);
          });
          pad.addEventListener("pointermove", (ev) => {
            if (!(ev.buttons & 1)) return;
            updateFromClient(ev.clientX, ev.clientY, true);
          });
          pad.addEventListener("pointerup", (ev) => {
            updateFromClient(ev.clientX, ev.clientY, true);
            if (pad.releasePointerCapture) {
              try { pad.releasePointerCapture(ev.pointerId); } catch (_) {}
            }
          });
          pad.addEventListener("pointercancel", (ev) => {
            if (pad.releasePointerCapture) {
              try { pad.releasePointerCapture(ev.pointerId); } catch (_) {}
            }
          });

          updateDotAndLabel();
          onChange(p, curX, curY);

          row.appendChild(nameEl);
          row.appendChild(ctrl);
          row.appendChild(valueEl);
          paramPanel.appendChild(row);
          continue;
        }

        const row = document.createElement("div");
        row.className = "paramRow";
        const nameEl = document.createElement("code");
        nameEl.textContent = `${p.name || "param"} (${p.uuid >>> 0})`;
        const slider = document.createElement("input");
        slider.type = "range";
        slider.className = "paramSlider paramCtrl";
        slider.min = String(minX);
        slider.max = String(maxX);
        slider.step = "0.001";
        slider.value = String(defX);
        const valueEl = document.createElement("span");
        valueEl.className = "paramVal";
        valueEl.textContent = `X:${defX.toFixed(3)}`;
        slider.addEventListener("input", () => {
          const x = clamp(Number(slider.value), minX, maxX);
          valueEl.textContent = `X:${x.toFixed(3)}`;
          onChange(p, x, defY);
        });
        row.appendChild(nameEl);
        row.appendChild(slider);
        row.appendChild(valueEl);
        paramPanel.appendChild(row);
      }
    }

    async function main() {
      await prepareWasmRuntime();
      await waitNicxRuntimeReady(window.Module);
      const apis = getWasmBindings();
      const codec = apis.codec;

      const glInit = initWebGLBackend(canvas, { debugLog: false });
      const backendCallbacks = glInit.backend.createUnityResourceCallbacks();

      const addFunction = Module.addFunction;
      if (!addFunction) throw new Error("addFunction is missing. Rebuild wasm with exported runtime method addFunction.");

      const layoutPtr = codec.getMalloc()(codec.layout.SizeWasmLayout);
      const layoutRes = apis.fnGetWasmLayout(layoutPtr);
      if (layoutRes === codec.layout.Ok) codec.applyWasmLayout(layoutPtr);
      else log("WARN", "njgGetWasmLayout failed:", layoutRes);
      apis.free(layoutPtr);

      const createTexturePtr = addFunction((w, h, ch, mip, fmt, rt, st, userData) => {
        return backendCallbacks.createTexture(w, h, ch, mip, fmt, !!rt, !!st) >>> 0;
      }, "iiiiiiiii");
      const updateTexturePtr = addFunction((handle, data, dataLen, w, h, ch, userData) => {
        const bytes = dataLen ? Module.HEAPU8.subarray(data, data + dataLen) : null;
        backendCallbacks.updateTexture(handle >>> 0, bytes, dataLen >>> 0, w | 0, h | 0, ch | 0);
      }, "viiiiiii");
      const releaseTexturePtr = addFunction((handle, userData) => {
        backendCallbacks.releaseTexture(handle >>> 0);
      }, "vii");

      const cfgPtr = codec.getMalloc()(codec.layout.UnityRendererConfig);
      const cbPtr = codec.getMalloc()(codec.layout.UnityResourceCallbacks);
      const outRendererPtr = codec.getMalloc()(codec.layout.OutPtr);
      Module.HEAP32[(cfgPtr >>> 2) + 0] = canvas.width | 0;
      Module.HEAP32[(cfgPtr >>> 2) + 1] = canvas.height | 0;
      Module.HEAPU32[(cbPtr >>> 2) + 0] = 0;
      Module.HEAPU32[(cbPtr >>> 2) + 1] = createTexturePtr >>> 0;
      Module.HEAPU32[(cbPtr >>> 2) + 2] = updateTexturePtr >>> 0;
      Module.HEAPU32[(cbPtr >>> 2) + 3] = releaseTexturePtr >>> 0;

      apis.fnRtInit();
      const cr = apis.fnCreateRenderer(cfgPtr, cbPtr, outRendererPtr);
      if (cr !== codec.layout.Ok) throw new Error(`njgCreateRenderer failed: ${cr}`);
      const renderer = readU32(outRendererPtr);
      if (!renderer) throw new Error("renderer handle is null");

      const modelUrl = String(modelSelect.value || "").trim();
      if (!modelUrl) throw new Error("model is not selected");
      const stagedPath = await codec.stageInxToMemfs(modelUrl);
      log("model staged:", stagedPath);

      const outPuppetPtr = codec.getMalloc()(codec.layout.OutPtr);
      const pathPtr = codec.writeCString(stagedPath);
      let lr = codec.layout.Failure;
      try {
        lr = apis.fnLoadPuppet(renderer, pathPtr, outPuppetPtr);
      } catch (e) {
        let stagedSize = -1;
        try {
          if (Module.FS_stat) stagedSize = Module.FS_stat(stagedPath).size | 0;
          else if (Module.FS && Module.FS.stat) stagedSize = Module.FS.stat(stagedPath).size | 0;
        } catch (_) {}
        apis.free(pathPtr);
        throw new Error(`njgLoadPuppet threw: ${String(e)} path=${stagedPath} size=${stagedSize}`);
      }
      apis.free(pathPtr);
      if (lr !== codec.layout.Ok) throw new Error(`njgLoadPuppet failed: ${lr}`);
      const puppet = readU32(outPuppetPtr);
      if (!puppet) throw new Error("puppet handle is null");

      if (apis.fnGetParameters && apis.fnUpdateParameters) {
        try {
          const outCountPtr = codec.getMalloc()(codec.layout.OutPtr);
          Module.HEAPU32[outCountPtr >>> 2] = 0;
          let pr = apis.fnGetParameters(puppet, 0, 0, outCountPtr);
          if (pr === codec.layout.Ok) {
            const count = readU32(outCountPtr);
            if (count > 0) {
              const infoPtr = codec.getMalloc()(count * codec.layout.SizeNjgParameterInfo);
              pr = apis.fnGetParameters(puppet, infoPtr, count, outCountPtr);
              if (pr === codec.layout.Ok) {
                const params = [];
                for (let i = 0; i < count; i += 1) {
                  params.push(codec.decodeParameterInfo(infoPtr + i * codec.layout.SizeNjgParameterInfo));
                }
                createParameterControls(params, (param, x, y) => {
                  const up = codec.getMalloc()(codec.layout.SizePuppetParameterUpdate);
                  Module.HEAPU32[(up >>> 2) + 0] = param.uuid >>> 0;
                  Module.HEAPF32[(up >>> 2) + 1] = x;
                  Module.HEAPF32[(up >>> 2) + 2] = y;
                  const rr = apis.fnUpdateParameters(puppet, up, 1);
                  if (rr !== codec.layout.Ok) log("WARN", "njgUpdateParameters failed:", rr, "uuid", param.uuid);
                  apis.free(up);
                });
              } else {
                log("WARN", "njgGetParameters(list) failed:", pr);
              }
              apis.free(infoPtr);
            } else {
              paramPanel.textContent = "parameters: none";
            }
          } else {
            log("WARN", "njgGetParameters(count) failed:", pr);
          }
          apis.free(outCountPtr);
        } catch (e) {
          log("WARN", "parameter UI unavailable:", String(e));
        }
      } else {
        paramPanel.textContent = "parameters: wasm exports not available";
      }

      const frameCfgPtr = codec.getMalloc()(codec.layout.FrameConfig);
      const cmdViewPtr = codec.getMalloc()(codec.layout.CommandQueueView);
      const snapshotPtr = codec.getMalloc()(codec.layout.SharedBufferSnapshot);

      let last = performance.now();
      let alive = true;
      let running = false;
      let rafId = 0;
      let debugFrame = 0;
      let panX = 0.0;
      let panY = 0.0;
      let dragging = false;
      let dragPointerId = -1;
      let dragLastX = 0;
      let dragLastY = 0;
      const cleanup = () => {
        if (!alive) return;
        alive = false;
        running = false;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = 0;
        }
        canvas.removeEventListener("pointerdown", onPointerDown);
        canvas.removeEventListener("pointermove", onPointerMove);
        canvas.removeEventListener("pointerup", onPointerUp);
        canvas.removeEventListener("pointercancel", onPointerUp);
        canvas.removeEventListener("wheel", onWheel);
        stopBtn.disabled = true;
        try { apis.fnUnloadPuppet(renderer, puppet); } catch (_) {}
        try { apis.fnDestroyRenderer(renderer); } catch (_) {}
        try { apis.fnRtTerm(); } catch (_) {}
      };
      window.addEventListener("beforeunload", cleanup);

      const clampScale = (v) => {
        const min = Number(scaleInput.min || "0.05");
        const max = Number(scaleInput.max || "2.0");
        return Math.max(min, Math.min(max, v));
      };
      const currentScale = () => {
        const s = Number(scaleInput.value || "1");
        return Number.isFinite(s) && s > 0 ? s : 1;
      };
      const applyPanScale = () => {
        const s = currentScale();
        scaleVal.textContent = s.toFixed(2);
        apis.fnSetPuppetScale(puppet, s, s);
        apis.fnSetPuppetTranslation(puppet, panX, panY);
      };

      const onPointerDown = (ev) => {
        dragging = true;
        dragPointerId = ev.pointerId;
        dragLastX = ev.clientX;
        dragLastY = ev.clientY;
        if (canvas.setPointerCapture) canvas.setPointerCapture(ev.pointerId);
      };
      const onPointerMove = (ev) => {
        if (!dragging || ev.pointerId !== dragPointerId) return;
        const dx = ev.clientX - dragLastX;
        const dy = ev.clientY - dragLastY;
        dragLastX = ev.clientX;
        dragLastY = ev.clientY;
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        panX += dx * dpr;
        panY += dy * dpr;
        applyPanScale();
      };
      const onPointerUp = (ev) => {
        if (ev.pointerId !== dragPointerId) return;
        dragging = false;
        dragPointerId = -1;
        if (canvas.releasePointerCapture) {
          try { canvas.releasePointerCapture(ev.pointerId); } catch (_) {}
        }
      };
      const onWheel = (ev) => {
        ev.preventDefault();
        const step = ev.deltaY < 0 ? 1.1 : 1.0 / 1.1;
        const s = clampScale(currentScale() * step);
        scaleInput.value = s.toFixed(3);
        applyPanScale();
      };
      canvas.addEventListener("pointerdown", onPointerDown);
      canvas.addEventListener("pointermove", onPointerMove);
      canvas.addEventListener("pointerup", onPointerUp);
      canvas.addEventListener("pointercancel", onPointerUp);
      canvas.addEventListener("wheel", onWheel, { passive: false });

      function resizeCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = Math.max(64, Math.floor(canvas.clientWidth * dpr));
        const h = Math.max(64, Math.floor(canvas.clientHeight * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
          glInit.drawableW = w;
          glInit.drawableH = h;
        }
      }

      function frame(now) {
        if (!alive || !running) return;
        try {
          resizeCanvas();

          const dt = Math.min(0.05, Math.max(0.0, (now - last) / 1000.0));
          last = now;

          applyPanScale();

          Module.HEAP32[(frameCfgPtr >>> 2) + 0] = canvas.width | 0;
          Module.HEAP32[(frameCfgPtr >>> 2) + 1] = canvas.height | 0;

          if (apis.fnBeginFrame(renderer, frameCfgPtr) !== codec.layout.Ok) {
            log("njgBeginFrame failed");
            requestAnimationFrame(frame);
            return;
          }
          apis.fnTickPuppet(puppet, dt);

          if (apis.fnEmitCommands(renderer, cmdViewPtr) !== codec.layout.Ok) {
            log("njgEmitCommands failed");
            requestAnimationFrame(frame);
            return;
          }
          if (apis.fnGetSharedBuffers(renderer, snapshotPtr) !== codec.layout.Ok) {
            log("njgGetSharedBuffers failed");
            requestAnimationFrame(frame);
            return;
          }

          const commandsPtr = readU32(cmdViewPtr + 0);
          const commandsCount = readU32(cmdViewPtr + 4);
          const commands = codec.decodeCommands(commandsPtr, commandsCount);
          const snapshot = codec.decodeSnapshot(snapshotPtr);
          let drawPartCount = 0;
          for (let i = 0; i < commands.length; i += 1) {
            if (Number(commands[i]?.kind) === NjgRenderCommandKind.DrawPart) drawPartCount += 1;
          }

          debugFrame += 1;
          if (WASM_TEST_LOG_ENABLED && (debugFrame <= 5 || (debugFrame % 60) === 0)) {
            const firstKind = commandsCount > 0 ? commands[0]?.kind : -1;
            log("frame", debugFrame, "cmdCount", commandsCount, "firstKind", firstKind,
              "drawPart", drawPartCount, "v/uv/d", snapshot.vertices.data.length, snapshot.uvs.data.length, snapshot.deform.data.length);
          }

          renderCommands(glInit, snapshot, { commands });
        } catch (e) {
          log("frame error:", String(e && e.message ? e.message : e));
        }
        rafId = requestAnimationFrame(frame);
      }

      const startLoop = () => {
        if (!alive || running) return;
        running = true;
        stopBtn.disabled = false;
        last = performance.now();
        rafId = requestAnimationFrame(frame);
      };
      const stopLoop = () => {
        running = false;
        stopBtn.disabled = true;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = 0;
        }
      };
      stopBtn.onclick = stopLoop;

      log("renderer ready, commands loop started");
      startLoop();
      return { startLoop, stopLoop, cleanup };
    }

    async function refreshModelListUI() {
      try {
        const models = await fetchModelList();
        fillModelSelect(models);
        log("models listed:", models.length);
      } catch (e) {
        fillModelSelect([]);
        log("WARN", "model list fetch failed:", String(e && e.message ? e.message : e));
      }
    }

    refreshModelsBtn.addEventListener("click", () => {
      refreshModelListUI();
    });

    async function launchSelectedModel({ forceReload = false } = {}) {
      if (isLaunching) return;
      isLaunching = true;
      startBtn.disabled = true;
      try {
        if (runtimeControl && forceReload) {
          try { runtimeControl.cleanup(); } catch (_) {}
          runtimeControl = null;
        }
        if (runtimeControl) {
          runtimeControl.startLoop();
          return;
        }
        runtimeControl = await main();
      } catch (e) {
        log("ERROR:", String(e && e.message ? e.message : e));
      } finally {
        startBtn.disabled = false;
        isLaunching = false;
      }
    }

    startBtn.addEventListener("click", () => {
      launchSelectedModel({ forceReload: false });
    });

    modelSelect.addEventListener("change", () => {
      launchSelectedModel({ forceReload: true });
    });

    await refreshModelListUI();
  </script>
</body>
</html>
